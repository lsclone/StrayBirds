---
layout: post
title: C++11使用总结
category: 技术
---

C++11相关应用总结：

#### 一、 C++11原子操作<atomic>

[Lock-Free 编程](http://www.tuicool.com/articles/JJRbieR "Markdown")

*示例代码*：

```
// atomic::compare_exchange_weak example:
#include <iostream>       // std::cout
#include <atomic>         // std::atomic
#include <thread>         // std::thread
#include <vector>         // std::vector
// a simple global linked list:
struct Node { int value; Node* next; };
std::atomic<Node*> list_head (nullptr);
void append (int val) {     // append an element to the list
  Node* newNode = new Node {val,list_head};
  // next is the same as: list_head = newNode, but in a thread-safe way:
  while (!list_head.compare_exchange_weak(newNode->next,newNode)) {}
  // (with newNode->next updated accordingly if some other thread just appended another node)
}
int main ()
{
  // spawn 10 threads to fill the linked list:
  std::vector<std::thread> threads;
  for (int i=0; i<10; ++i) threads.push_back(std::thread(append,i));
  for (auto& th : threads) th.join();
  // print contents:
  for (Node* it = list_head; it!=nullptr; it=it->next)
    std::cout << ' ' << it->value;
  std::cout << '\n';
  // cleanup:
  Node* it; while (it=list_head) {list_head=it->next; delete it;}
  return 0;
}
```

*参考文档*：

1. [msdn社区<atomic>介绍](https://msdn.microsoft.com/zh-cn/library/hh874894.aspx "atomic")
2. [<atomic> 类型详解二 std::atomic](http://www.cnblogs.com/haippy/archive/2013/09/05/3301408.html "atomic")
3. [C++11中的原子操作（atomic operation）](http://blog.csdn.net/yockie/article/details/8838686 "atomic")
4. [C++并发实战16: std::atomic原子操作](http://blog.csdn.net/liuxuejiang158blog/article/details/17413149 "atomic")

#### 二、 C++11多线程<thread>

*参考文档*：

1. [C++11 多线程初探](http://www.cnblogs.com/haippy/p/3235560.html "thread")
2. [C++11 multithreading tutorial](https://solarianprogrammer.com/2011/12/16/cpp-11-thread-tutorial/ "thread")
3. [C++官网：multithreading相关类介绍](http://www.cplusplus.com/reference/multithreading/ "thread")
4. [C++11 run templated class function with std::thread](http://stackoverflow.com/questions/21485578/c11-run-templated-class-function-with-stdthread "thread")
5. [C++ std::thread of a member function](http://stackoverflow.com/questions/18383600/c-stdthread-of-a-member-function "thread")
6. [shared_ptr和多线程](http://www.cnblogs.com/wpcockroach/p/3611747.html "thread")
7. [C++开发：为什么多线程读写shared_ptr要加锁的详细介绍](http://www.jb51.net/article/36210.htm "thread")

*实例*：

Thread.h

```
#ifndef __THREAD_H__
#define __THREAD_H__

#include <thread>
#include <memory>

class Thread {
public:
	virtual ~Thread() {}
	void start(std::shared_ptr<Thread> ptr);

protected:
	virtual void run() {}

private:
	static void invoke(std::shared_ptr<Thread> ptr);
};

#endif //__THREAD_H__
```

Thread.cpp

```
#include "Thread.h"

void Thread::start(std::shared_ptr<Thread> ptr) {
	if (this == ptr.get()) {
		std::thread thd(Thread::invoke, ptr);
		thd.detach();
	}
}

void Thread::invoke(std::shared_ptr<Thread> ptr) {
	if (nullptr != ptr.get()) {
		ptr.get()->run();
	}
}
```

main.cpp

```
#include <atomic>
#include "Thread.h"

class TestThread : public Thread {
public:
	TestThread(int count) : m_count(count) {}
	int reduce();

protected:
	virtual void run();

private:
	std::atomic<int> m_count;
};

int TestThread::reduce() {
	return --m_count;
}

void TestThread::run() {
	while (m_count > 0) {
		m_count--;
	}
}

int main() {
	for (int i = 0; i < 1000; i++) {
		std::shared_ptr<Thread> ptr(new TestThread(1000));
		ptr.get()->start(ptr);

		while (((TestThread*)ptr.get())->reduce() > 0) {}
	}
	return 0;
}
```

#### 三、 C++11智能指针<shared_ptr>

*参考文档*：

1. [C++11中的智能指针](http://www.jellythink.com/archives/684 "")

#### 四、 右值引用 T&&

```
class Mem {
public:
	~Mem();
	Mem() : m_str(nullptr), m_len(0) {}
	Mem(const char* str, int len);
	Mem(const Mem& obj);
	Mem(Mem&& obj);
	Mem& operator=(Mem&& obj);
private:
	int m_len;
	char* m_str;
};

Mem::~Mem() {
	if (m_str != nullptr) {
		delete[] m_str;
	}
}

Mem::Mem(const char* str, int len) {
	m_str = new char[len + 1];
	memcpy(m_str, str, len);
	m_str[len] = '\0';
	m_len = len;
}

Mem::Mem(const Mem& obj) {
	m_str = new char[obj.m_len + 1];
	memcpy(m_str, obj.m_str, obj.m_len);
	m_str[obj.m_len] = '\0';
	m_len = obj.m_len;
}

// move construction
Mem::Mem(Mem&& obj) {
	m_str = obj.m_str;
	m_len = obj.m_len;
	obj.m_str = nullptr;
	obj.m_len = 0;
}

// move assignment operator
Mem& Mem::operator=(Mem&& obj) {
	std::swap(m_str, obj.m_str);
	std::swap(m_len, obj.m_len);
	return (*this);
}

void main() {
	std::list<Mem> mlist;
	mlist.push_back(std::move(Mem("hello", strlen("hello")))); // call move construction
	mlist.push_back(std::move(Mem("world", strlen("world"))));
	
	std::map<int, Mem> mp;
	mp[0] = std::move(lsclone::Mem("hello", strlen("hello"))); // call move assignment operator
	mp[1] = std::move(lsclone::Mem("world", strlen("world")));
}

```

说明：

* move construction即右值引用构造函数；
* 需要调用std::move()获取对象的右值引用；
* STL模板类支持右值引用构造对象；
* 如果没有实现move construction，上述list.push_back()会调用copy construction；
* 如果move construction和copy construction都没有实现，则成员变量直接拷贝。

#### 五、auto关键字

1、 **auto不能用来声明函数的返回值**。但如果函数有一个尾随的返回类型时，auto是可以出现在函数声明中返回值位置。这种情况下，auto并不是告诉编译器去推断返回类型，而是指引编译器去函数的末端寻找返回值类型。在下面这个例子中，函数的返回值类型就是operator+操作符作用在T1、T2类型变量上的返回值类型。

```
template <typename T1, typename T2>
auto compose(T1 t1, T2 t2) -> decltype(t1 + t2)
{
   return t1+t2;
}
auto v = compose(2, 3.14); 
// v's type is double
```

2、 **auto不能用作函数的形参**，如果传递匿名函数，需要使用std::function

```
#include <functional>

void invoke(std::function<int(int&, int&)> func) {
	int a = 10, b = 22;
	int sum = func(a, b);
}

void main() {
	std::function<int(int&, int&)> swap_func = [](int& a, int& b) -> int {
		a ^= b;
		b ^= a;
		a ^= b;
		return (a+b);
	};

	invoke(swap_func);
}
```

#### 六、C++临时对象

待总结...

*参考文档*：

* [C++中的临时对象](http://www.cnblogs.com/avril/archive/2010/10/20/1856320.html "makrdown")
* [小问题大思考之C++临时对象](http://blog.csdn.net/imyfriend/article/details/12886577 "makrdown")

#### 七、多线程编程之\<future\>

*参考文档*：

* [C++11 并发指南四(\<future\> 详解一 std::promise 介绍)](http://www.cnblogs.com/haippy/p/3239248.html "markdown")
* [C++11 并发指南四(\<future\> 详解二 std::packaged_task 介绍)](http://www.cnblogs.com/haippy/p/3279565.html "markdown")
* [C++11 并发指南四(\<future\> 详解三 std::future & std::shared_future)](http://www.cnblogs.com/haippy/p/3280643.html "markdown")
* [用C++11的std::async代替线程的创建](http://www.tuicool.com/articles/6j2u2qa "markdown")
* [C++官网：std::future](http://www.cplusplus.com/reference/future/ "markdown")

#### 八、可变参数个数的模板

在C++11 之前, 不论是模板类或是模板函数，都只能按其被声明时所指定的样子，接受一组固定数目的模板实参； 
C++11 加入新的表示法，允许任意个数、任意类别的模板实参，不必在定义时将实参的个数固定。

```
template<typename... Values> class tuple;
```

模板类tuple 的对象，能接受不限个数的typename 作为它的模板形参：

```
class tuple<int, std::vector<int>, std::map<std::string, std::vector<int>>> someInstanceName
```

实参的个数也可以是 0，所以class tuple<> someInstanceName 这样的定义也是可以的。

若不希望产生实参个数为0 的变长参数模板，则可以采用以下的定义：

```
template<typename First, typename... Rest> class tuple;
```

变长参数的数量可以藉以下的语法得知：

```
template<typename ...Args> struct SomeStruct
{
	static const int size = sizeof...(Args);
}
```

参考实例：

```
template <typename T>
void myprintf(const char *s, T value)
{
	if (*s == '%') {
		cout << value <<endl;
	}
	return;
}

template <typename T, typename... Args>
void myprintf(const char *s, T value, Args... args)
{
	if (*s == '%') {
		cout << value << '\t';
		myprintf<Args>(s+1, args...);
	}
	return;
}
```

详细介绍参考：[C++11标准中文版文档](http://download.csdn.net/detail/herojia_1/6013155 "markdown")的**6.1 变长参数模板**

*参考网址*：[C++11中可变参数个数的模板（variadic template）](http://m.blog.csdn.net/blog/herojia_1/10328791 "markdown")

####九、 lambda应用之ScopeGuard

scopeguard.h

```
#ifndef scopeguard_h__
#define scopeguard_h__

#include <utility>

namespace sg
{
    template <class Fun>
    class ScopeGuard {
        Fun f_;
        bool active_;
    public:
        ScopeGuard(Fun f)
            : f_(std::move(f))
            , active_(true) {
        }
        ~ScopeGuard() { if (active_) f_(); }
        void dismiss() { active_ = false; }
        ScopeGuard(ScopeGuard&& rhs)
            : f_(std::move(rhs.f_))
            , active_(rhs.active_) {
                rhs.dismiss();
        }
    };

    namespace detail {
        class ScopeGuardOnExit {};
        template <typename Fun>
        ScopeGuard<Fun> operator+(ScopeGuardOnExit, Fun&& fn) {
            return ScopeGuard<Fun>(std::forward<Fun>(fn));
        }
    }
}

#define SCOPE_EXIT \
    auto ANONYMOUS_VARIABLE(SCOPE_EXIT_STATE) \
	= sg::detail::ScopeGuardOnExit() + [&]()

#define CONCATENATE_IMPL(s1, s2) s1##s2
#define CONCATENATE(s1, s2) CONCATENATE_IMPL(s1, s2)
#ifdef __COUNTER__
#define ANONYMOUS_VARIABLE(str) \
    CONCATENATE(str, __COUNTER__)
#else
#define ANONYMOUS_VARIABLE(str) \
    CONCATENATE(str, __LINE__)
#endif

#endif // scopeguard_h__
```

main.cpp

```
#include <stdio.h>
#include "scopeguard.h"

int test() {
	SCOPE_EXIT{
		printf("end of test()\n");
	};
	return 0;
}

void main() {

	test();

	{
		SCOPE_EXIT{
			printf("end of main()\n");
		};
	}
}
```

*参考文档*：[如何退出函数时再做一些固定的事情（比如释放内存）--scopeguard](http://blog.csdn.net/lixingying567/article/details/45313123 "scopeguard")

=========================================================================

*参考文档*：

* [C++开发者都应该使用的10个C++11特性](http://blog.jobbole.com/44015/ "markdown")
* [主流编译器对C++11的支持情况](http://cpp1x.org/compiler-support.html "markdown")
* [Visual C++ 中的 C++11/14/17 功能](https://msdn.microsoft.com/zh-cn/library/hh567368.aspx "markdown")
* [关于C++11中的std::move和std::forward](http://blog.sina.com.cn/s/blog_53b7ddf00101p5t0.html "markdown")
* [cppreference.com std::forward](http://en.cppreference.com/w/cpp/utility/forward "markdown")
