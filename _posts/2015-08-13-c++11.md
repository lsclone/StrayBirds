---
layout: post
title: C++11使用总结
category: 技术
---

C++11相关应用总结：

#### 一、 C++11原子操作<atomic>

*示例代码*：

```
// atomic::compare_exchange_weak example:
#include <iostream>       // std::cout
#include <atomic>         // std::atomic
#include <thread>         // std::thread
#include <vector>         // std::vector
// a simple global linked list:
struct Node { int value; Node* next; };
std::atomic<Node*> list_head (nullptr);
void append (int val) {     // append an element to the list
  Node* newNode = new Node {val,list_head};
  // next is the same as: list_head = newNode, but in a thread-safe way:
  while (!list_head.compare_exchange_weak(newNode->next,newNode)) {}
  // (with newNode->next updated accordingly if some other thread just appended another node)
}
int main ()
{
  // spawn 10 threads to fill the linked list:
  std::vector<std::thread> threads;
  for (int i=0; i<10; ++i) threads.push_back(std::thread(append,i));
  for (auto& th : threads) th.join();
  // print contents:
  for (Node* it = list_head; it!=nullptr; it=it->next)
    std::cout << ' ' << it->value;
  std::cout << '\n';
  // cleanup:
  Node* it; while (it=list_head) {list_head=it->next; delete it;}
  return 0;
}
```

*参考文档*：

1. [msdn社区<atomic>介绍](https://msdn.microsoft.com/zh-cn/library/hh874894.aspx "atomic")
2. [<atomic> 类型详解二 std::atomic](http://www.cnblogs.com/haippy/archive/2013/09/05/3301408.html "atomic")
3. [C++11中的原子操作（atomic operation）](http://blog.csdn.net/yockie/article/details/8838686 "atomic")
4. [C++并发实战16: std::atomic原子操作](http://blog.csdn.net/liuxuejiang158blog/article/details/17413149 "atomic")

#### 二、 C++11多线程<thread>

*参考文档*：

1. [C++11 多线程初探](http://www.cnblogs.com/haippy/p/3235560.html "thread")
2. [C++11 multithreading tutorial](https://solarianprogrammer.com/2011/12/16/cpp-11-thread-tutorial/ "thread")
3. [C++官网：multithreading相关类介绍](http://www.cplusplus.com/reference/multithreading/ "thread")
4. [C++11 run templated class function with std::thread](http://stackoverflow.com/questions/21485578/c11-run-templated-class-function-with-stdthread "thread")
5. [C++ std::thread of a member function](http://stackoverflow.com/questions/18383600/c-stdthread-of-a-member-function "thread")
6. [shared_ptr和多线程](http://www.cnblogs.com/wpcockroach/p/3611747.html "thread")
7. [C++开发：为什么多线程读写shared_ptr要加锁的详细介绍](http://www.jb51.net/article/36210.htm "thread")

*实例*：

Thread.h

```
#ifndef __THREAD_H__
#define __THREAD_H__

#include <thread>
#include <memory>

class Thread {
public:
	virtual ~Thread() {}
	void start(std::shared_ptr<Thread> ptr);

protected:
	virtual void run() {}

private:
	static void invoke(std::shared_ptr<Thread> ptr);
};

#endif //__THREAD_H__
```

Thread.cpp

```
#include "Thread.h"

void Thread::start(std::shared_ptr<Thread> ptr) {
	if (this == ptr.get()) {
		std::thread thd(Thread::invoke, ptr);
		thd.detach();
	}
}

void Thread::invoke(std::shared_ptr<Thread> ptr) {
	if (nullptr != ptr.get()) {
		ptr.get()->run();
	}
}
```

main.cpp

```
#include <atomic>
#include "Thread.h"

class TestThread : public Thread {
public:
	TestThread(int count) : m_count(count) {}
	int reduce();

protected:
	virtual void run();

private:
	std::atomic<int> m_count;
};

int TestThread::reduce() {
	return --m_count;
}

void TestThread::run() {
	while (m_count > 0) {
		m_count--;
	}
}

int main() {
	for (int i = 0; i < 1000; i++) {
		std::shared_ptr<Thread> ptr(new TestThread(1000));
		ptr.get()->start(ptr);

		while (((TestThread*)ptr.get())->reduce() > 0) {}
	}
	return 0;
}
```

#### 三、 C++11智能指针<shared_ptr>

*参考文档*：

1. [C++11中的智能指针](http://www.jellythink.com/archives/684 "")

#### 四、 右值引用 T&&

```
class Mem {
public:
	~Mem();
	Mem() : m_str(nullptr), m_len(0) {}
	Mem(const char* str, int len);
	Mem(const Mem& obj);
	Mem(Mem&& obj);
	Mem& operator=(Mem&& obj);
private:
	int m_len;
	char* m_str;
};

Mem::~Mem() {
	if (m_str != nullptr) {
		delete[] m_str;
	}
}

Mem::Mem(const char* str, int len) {
	m_str = new char[len + 1];
	memcpy(m_str, str, len);
	m_str[len] = '\0';
	m_len = len;
}

Mem::Mem(const Mem& obj) {
	m_str = new char[obj.m_len + 1];
	memcpy(m_str, obj.m_str, obj.m_len);
	m_str[obj.m_len] = '\0';
	m_len = obj.m_len;
}

// move construction
Mem::Mem(Mem&& obj) {
	m_str = obj.m_str;
	m_len = obj.m_len;
	obj.m_str = nullptr;
	obj.m_len = 0;
}

// move assignment operator
Mem& Mem::operator=(Mem&& obj) {
	std::swap(m_str, obj.m_str);
	std::swap(m_len, obj.m_len);
	return (*this);
}

void main() {
	std::list<Mem> mlist;
	mlist.push_back(std::move(Mem("hello", strlen("hello")))); // call move construction
	mlist.push_back(std::move(Mem("world", strlen("world"))));
	
	std::map<int, Mem> mp;
	mp[0] = std::move(lsclone::Mem("hello", strlen("hello"))); // call move assignment operator
	mp[1] = std::move(lsclone::Mem("world", strlen("world")));
}

```

说明：

* move construction即右值引用构造函数；
* 需要调用std::move()获取对象的右值引用；
* STL模板类支持右值引用构造对象；
* 如果没有实现move construction，上述list.push_back()会调用copy construction；
* 如果move construction和copy construction都没有实现，则成员变量直接拷贝。

=========================================================================

*参考文档*：

* [主流编译器对C++11的支持情况](http://cpp1x.org/compiler-support.html "markdown")
* [Visual C++ 中的 C++11/14/17 功能](https://msdn.microsoft.com/zh-cn/library/hh567368.aspx "markdown")
