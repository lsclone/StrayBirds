---
layout: post
title: OpenGL介绍及使用
category: 技术
---

[OpenGL API](https://www.opengl.org/sdk/docs/man4/html/ "opengl")

**学习前瞻：**

* [Nehe OpenGL 教程是否过时？](http://www.zhihu.com/question/24162747 "Markdown")
* [Learning Modern OpenGL](http://www.codeproject.com/Articles/771225/Learning-Modern-OpenGL "Markdown")
* [Learning Modern 3D Graphics Programming](http://alfonse.bitbucket.org/oldtut/ "Markdown")

**学习视频：**

* [Up and Running with OpenGL](http://www.lynda.com/OpenGL-tutorials/Up-Running-OpenGL/166782-2.html?utm_source=google&utm_medium=cpc&utm_campaign=l1-US-Search-Dev-OpenGL&cid=l1-us:en:ps:lp:prosc:s50:2786:all:google:mbm-learn_opengl&utm_content=64970769666&utm_term=%2Blearn%20%2Bopengl&device=c&gclid=CMfatuTO88kCFVgnvQodljQDOg "Markdown")

**参考网址：**

* [引路蜂技术博客](https://pstreets.wordpress.com/tag/opengl-es/ "Markdown")
* [Learn OpenGL ES for Android](http://www.learnopengles.com/ "Markdown")
* [NeHe中文教程](http://www.yakergong.net/nehe/ "Markdown")
* [OpenGL模型加载](http://202.117.94.248/teach/c/NeHeCHS/course/tutorial_31.htm "Markdown")
* [OpenGL维基百科](https://zh.wikipedia.org/zh-cn/OpenGL "Markdown")
* [OpenGL官网](https://www.opengl.org/wiki/Getting_Started "Markdown")
* [OpenGL ES](https://www.khronos.org/opengles/ "Markdown")
* [Android OpenGL ES](http://developer.android.com/guide/topics/graphics/opengl.html#choosing-version "Markdown")
* [Mali GPU OpenGL ES 应用性能优化--基本方法](http://blog.csdn.net/myarrow/article/details/17583559 "Markdown")

####0. OpenGL相关介绍

* OpenGL ES和游戏引擎的区别和联系

OpenGL ES 是一套专为嵌入式设备设计的三维图形开发接口标准, 脱胎于 OpenGL. 

OpenGL 家族以及他的主要竞争对手 Direct3D 都只是一套 API(说白了就是N个函数)标准, 显卡厂商根据标准开发出驱动,有了驱动 (当然还有SDK) 我们程序员就可以开始对显卡编程制作出绚丽的3D游戏.

程序员在开发游戏过程中发现不同游戏都要实现相同功能, 比如资源管理, 声音播放, 渲染. 于是很自然程序员就开始制作自己的工具完成这些重复工作, 游戏引擎就诞生了.

其中游戏引擎的一个工作就是抽象 OpenGL , D3D 这些底层API, 你再也不需要分别为OpenGL, D3D 编码, 只要调用引擎的抽象接口, 剩下的就交给引擎了.

用 Unity 发布 Android, iOS 的游戏, 那他就调用和绑定 OpenGL ES,

发布 PC 游戏, 就是D3D 或者 OpenGL.

* GPU 概述

首先，GPU要处理的事情，有以下几种：

3D，处理OpenGL ES;

2D的composition，包括BitBLT，Rotate等等，可以当是UI的合成（想象一层壁纸，一层图标，一层状态栏等），主要操作还是基于像素的;

2D的Vector Graphics，OpenVG，SVG，Flash之类的用用，绘制矢量图形;

所以，我们简称如下：3D， 2D-Composition， 2D-VG.

*参考网址：*

* [How does a GPU/CPU communicate with a standard display output? (HDMI/DVI/etc)](http://electronics.stackexchange.com/questions/102695/how-does-a-gpu-cpu-communicate-with-a-standard-display-output-hdmi-dvi-etc "opengl")

####1. 如何在glutMainLoop()循环中正常返回，not exit

```
#include "GL/glew.h"
#include "GL/freeglut.h"

int main(int argc, char** argv) {

	glutInit(&argc, argv);

	if (GLUT_API_VERSION >= 4) {
		glutInitDisplayString( "rgb double depth>=24 samples" );
	} else {
		glutInitDisplayMode( GLUT_RGBA | GLUT_DEPTH | GLUT_DOUBLE );
	}

	glutInitWindowPosition(0,0);
	glutInitWindowPosition(500, 500);
	glutInitWindowSize(640, 480);
	glutCreateWindow("opengl");

	if (glewInit() != GLEW_OK) {
		return -1;
	}

  glutKeyboardFunc(Keyboard);
  glutReshapeFunc(reshape_func_ptr);
  glutDisplayFunc(display_func_ptr);
  glutIdleFunc(glutPostRedisplay);  //opengl free time callback
  
  glutSetOption(GLUT_ACTION_ON_WINDOW_CLOSE, GLUT_ACTION_CONTINUE_EXECUTION); // **
  glutMainLoop(); // **
  
  return 0;
}

void Keyboard(unsigned char key, int x, int y) {
	switch( key ) {
	case 27: // esc
		glutLeaveMainLoop(); // **
		break;
	default:
	  break;
	}
}
```

*参考网址*：[How to close GLUT window without terminating of application](http://stackoverflow.com/questions/17972275/how-to-close-glut-window-without-terminating-of-application "opengl")

####2. OpenGL纹理

```
...
glEnable(GL_TEXTURE_2D);
...
glDisable(GL_TEXTURE_2D);
...
```

```
GLuint texID_ = 0;
...
if (0 == texID_) {
	// create texture
	glGenTextures(1, &texID_);
	glBindTexture(GL_TEXTURE_2D, texID_);
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
	glTexImage2D(GL_TEXTURE_2D, 0, GL_RGB, image->width, image->height, 0,
		GL_RGB, GL_UNSIGNED_BYTE, image->imageData);
} else {
	glBindTexture(GL_TEXTURE_2D, texID_);
	glTexSubImage2D(GL_TEXTURE_2D, 0, 0, 0, image->width, image->height,
		GL_RGB, GL_UNSIGNED_BYTE, image->imageData);
}
...
// release texture
glDeleteTextures(1, &texID_);
texID_ = 0;
```

* [纹理映射](http://cose.seu.edu.cn/seuGraph/AdminComponents%5cUploadedCourseAcc%5c7.2_%E7%BA%B9%E7%90%86%E6%98%A0%E5%B0%84.pdf "texture")
* [OpenGL纹理简介](http://www.cnblogs.com/yxnchinahlj/archive/2010/11/19/1881517.html "texture")

####3. OpenGL混合(Blend)

OpenGL 会把源颜色和目标颜色各自取出，并乘以一个系数（源颜色乘以的系数称为“源因子”，目标颜色乘以的系数称为“目标因子”），然后相加，这样就得到了新的颜 色。（也可以不是相加，新版本的OpenGL可以设置运算方式，包括加、减、取两者中较大的、取两者中较小的、逻辑运算等，但我们这里为了简单起见，不讨 论这个了） 下面用数学公式来表达一下这个运算方式。假设源颜色的四个分量（指红色，绿色，蓝色，alpha值）是(Rs, Gs, Bs, As)，目标颜色的四个分量是(Rd, Gd, Bd, Ad)，又设源因子为(Sr, Sg, Sb, Sa)，目标因子为(Dr, Dg, Db, Da)。则混合产生的新颜色可以表示为： (Rs*Sr+Rd*Dr, Gs*Sg+Gd*Dg, Bs*Sb+Bd*Db, As*Sa+Ad*Da) 当然了，如果颜色的某一分量超过了1.0，则它会被自动截取为1.0。

* GL\_ONE： 表示使用1.0作为因子，实际上相当于完全的使用了这种颜色参与混合运算。
* GL\_SRC\_ALPHA：表示使用源颜色的alpha值来作为因子。
* GL\_DST\_ALPHA：表示使用目标颜色的alpha值来作为因子。
* GL\_ONE\_MINUS\_SRC\_ALPHA：表示用1.0减去源颜色的alpha值来作为因子。
* GL\_ONE\_MINUS\_DST\_ALPHA：表示用1.0减去目标颜色的alpha值来作为因子。


*参考文档*：

* [OpenGL glBlendFunc() 设置颜色混合 透明度叠加计算](http://blog.chinaunix.net/uid-20622737-id-2850251.html "blend")
* [颜色混合opengl](http://blog.csdn.net/aurora_mylove/article/details/1700540 "blend")

####4. OpenGL模型加载相关-网格

*参考文档*：

![mesh](http://glvis.org/img/glvis-saved.png "mesh")

* [网格(Mesh)-中文](http://learnopengl-cn.readthedocs.org/zh/latest/03%20Model%20Loading/02%20Mesh/ "mesh")
* [网格(Mesh)-英文原文](http://learnopengl.com/#!Model-Loading/Mesh "mesh")

####5. OpenGL ES 2.0 shader

![opengle render pipeline](https://open.gl/media/img/c2_pipeline.png "shader")

*参考文档*

* [【OpenGL】理解一些基本问题](http://blog.csdn.net/candycat1992/article/details/39675513 "shader")
* [OpenGL ES 2.0渲染管线](http://codingnow.cn/opengles/1504.html "shader")

####6. OpenGL ES 2.0 sample

*参考：*

* [win7下搭建opengl es 2.0开发环境](http://codingnow.cn/opengles/1501.html "opengl es 2.0")
* [OpenGL ES 2.0 绘制一个三角形](http://codingnow.cn/opengles/1514.html "opengl es 2.0")

*全用例参考：* [opengles-book-samples(github)](https://github.com/lsclone/opengles-book-samples "opengl es 2.0")

*备注：*
运行sample(Hello_Triangle)，需要修改： 工程属性->General->Output Directory： **..\..\Bin**

####7. EGL

OpenGL是一个操作GPU的API，它通过驱动向GPU发送相关指令，控制图形渲染管线状态机的运行状态。
但OpenGL需要本地视窗系统进行交互，这就需要一个中间控制层，最好与平台无关。

EGL——因此被独立的设计出来，它作为OpenGL ES和本地窗口的桥梁。

EGL 是 OpenGL ES（嵌入式）和底层 Native 平台视窗系统之间的接口。

EGL API 是独立于OpenGL ES各版本标准的独立API， 其主要作用是为OpenGL指令创建 Context、绘制目标Surface、 配置Framebuffer属性、Swap提交绘制结果等。

一般来说，OpenGL ES 图形管线的状态被存储于 EGL 管理的一个Context中。
而Frame Buffers 和其他绘制 Surfaces 通过 EGL API进行创建、管理和销毁。 
EGL 同时也控制和提供了对设备显示和可能的设备渲染配置的访问。

*参考：* [OpenGL ES：EGL接口解析与理解](http://imgtec.eetrend.com/blog/6839 "egl")
